package com.arcao.geocaching4locus.base.util;

import android.app.Service;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.PowerManager;
import android.util.Log;
import android.util.SparseArray;
import timber.log.Timber;

public class ServiceUtil {
  private static final String EXTRA_WAKE_LOCK_ID = ServiceUtil.class.getCanonicalName() +".WAKE_LOCK_ID";

  private static final SparseArray<WakeLockContainer> sActiveWakeLocks = new SparseArray<>();
  private static int mNextId = 1;

  private ServiceUtil() {}

  /**
   * Do a {@link Context#startService(Intent)
   * Context.startService}, but holding a wake lock while the service starts.
   * This will modify the Intent to hold an extra identifying the wake lock;
   * when the service receives it in {@link Service#onStartCommand
   * Service.onStartCommand}, it should pass back the Intent it receives there to
   * {@link #completeWakefulIntent(Intent)} in order to release
   * the wake lock.
   *
   * @param context The Context in which it operate.
   * @param intent The Intent with which to start the service, as per
   * {@link Context#startService(Intent)
   * Context.startService}.
   */
  public static ComponentName startWakefulForegroundService(Context context, Intent intent) {
    synchronized (sActiveWakeLocks) {
      int id = mNextId;
      mNextId++;
      if (mNextId <= 0) {
        mNextId = 1;
      }

      intent.putExtra(EXTRA_WAKE_LOCK_ID, id);
      ComponentName comp = Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ?
          context.startForegroundService(intent) : context.startService(intent);

      if (comp == null) {
        return null;
      }

      PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
      if (pm == null) {
        return comp;
      }

      String tag = "wake:" + comp.flattenToShortString();
      PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, tag);
      wl.setReferenceCounted(false);
      wl.acquire(60 * 1000);
      sActiveWakeLocks.put(id, new WakeLockContainer(tag, wl));
      return comp;
    }
  }

  /**
   * Finish the execution from a previous {@link #startWakefulForegroundService}.  Any wake lock
   * that was being held will now be released.
   *
   * @param intent The Intent as originally generated by {@link #startWakefulForegroundService}.
   * @return Returns true if the intent is associated with a wake lock that is
   * now released; returns false if there was no wake lock specified for it.
   */
  public static boolean completeWakefulIntent(Intent intent) {
    final int id = intent.getIntExtra(EXTRA_WAKE_LOCK_ID, 0);
    if (id == 0) {
      return false;
    }
    synchronized (sActiveWakeLocks) {
      WakeLockContainer container = sActiveWakeLocks.get(id);
      if (container != null) {
        container.wakeLock.release();
        sActiveWakeLocks.remove(id);
        return true;
      }
      // We return true whether or not we actually found the wake lock
      // the return code is defined to indicate whether the Intent contained
      // an identifier for a wake lock that it was supposed to match.
      // We just log a warning here if there is no wake lock found, which could
      // happen for example if this function is called twice on the same
      // intent or the process is killed and restarted before processing the intent.
      Log.w("WakefulBroadcastReceiv.", "No active wake lock id #" + id);
      return true;
    }
  }

  public static void releaseAllWakeLocks(ComponentName component) {
    String tag = "wake:" + component.flattenToShortString();

    synchronized (sActiveWakeLocks) {
      for (int i = 0; i < sActiveWakeLocks.size(); i++) {
        int id = sActiveWakeLocks.keyAt(i);
        WakeLockContainer container = sActiveWakeLocks.get(id);
        if (!tag.equals(container.tag)) {
          continue;
        }

        container.wakeLock.release();
        sActiveWakeLocks.remove(id);
      }
      Timber.w("WakeLock remaining: %d", sActiveWakeLocks.size());
    }
  }

  private static class WakeLockContainer {
    final String tag;
    final PowerManager.WakeLock wakeLock;

    WakeLockContainer(String tag, PowerManager.WakeLock wakeLock) {
      this.tag = tag;
      this.wakeLock = wakeLock;
    }
  }
}
